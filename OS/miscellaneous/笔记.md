#### 保护模式和全局描述符

##### 为什么要有保护模式

实模式下应用程序可以访问CPU的整个内存空间，十分危险。

80286 保护16位

##### 保护模式在保护什么？

- 数据，信息
- 寄存器
- 内存 / 描述符
- 外部设备 

##### 全局描述符

包含信息有：

- 内存起始位置
- 内存长度和界限
- 内存的属性

[80826](/home/yuanfang/study/LearnOS/miscellaneous/image/80286-segment descriptor.jpg)


tss的作用举例：保存不同特权级别下任务所使用的寄存器，特别重要的是esp，因为比如中断后，涉及特权级切换时(一个任务切换)，首先要切换栈，这个栈显然是内核栈，那么如何找到该栈的地址呢，这需要从tss段中得到，这样后续的执行才有所依托(在x86机器上，c语言的函数调用是通过栈实现的)。只要涉及地特权环到高特权环的任务切换，都需要找到高特权环对应的栈，因此需要esp2，esp1，esp0起码三个esp，然而Linux只使用esp0。

tss是什么：tss是一个段，段是x86的概念，在保护模式下，段选择符参与寻址，段选择符在段寄存器中，而tss段则在tr寄存器中。

intel的建议：为每一个进程准备一个独立的tss段，进程切换的时候切换tr寄存器使之指向该进程对应的tss段，然后在任务切换时(比如涉及特权级切换的中断)使用该段保留所有的寄存器。

Linux的做法：

1.Linux没有为每一个进程都准备一个tss段，而是每一个cpu使用一个tss段，tr寄存器保存该段。进程切换时，只更新唯一tss段中的esp0字段到新进程的内核栈。

2.Linux的tss段中只使用esp0和iomap等字段，不用它来保存寄存器，在一个用户进程被中断进入ring0的时候，tss中取出esp0，然后切到esp0，其它的寄存器则保存在esp0指示的内核栈上而不保存在tss中。

3.结果，Linux中每一个cpu只有一个tss段，tr寄存器永远指向它。符合x86处理器的使用规范，但不遵循intel的建议，这样的后果是开销更小了，因为不必切换tr寄存器了。

4.在Linux中，对于同一个CPU，所有的进程都使用一个TSS，只是在进程切换时， 被切换到的进程将会把自己的ESP0保存到TSS.ESP0中去，那为什么不把自己的SS0也保存到TSS.SS0中 呢，这是因为所有进程的SS0都是统一的，为内核的SS，而内核在初始化的时候，已经将该TSS.SS0设置为自己的SS，因此无需继续设置SS0。


Linux的实现：

1.定义tss：
struct tss_struct init_tss[NR_CPUS] __cacheline_aligned = { [0 ... NR_CPUS-1] = INIT_TSS };(arch/i386/kernel/init_task.c)
INIT_TSS定义为：
#define INIT_TSS  {                            \
    .esp0        = sizeof(init_stack) + (long)&init_stack,    \
    .ss0        = __KERNEL_DS,                    \
    .esp1        = sizeof(init_tss[0]) + (long)&init_tss[0],    \
    .ss1        = __KERNEL_CS,                    \
    .ldt        = GDT_ENTRY_LDT,                \
    .io_bitmap_base    = INVALID_IO_BITMAP_OFFSET,            \
    .io_bitmap    = { [ 0 ... IO_BITMAP_LONGS] = ~0 },        \
}

 


 ;在页目录内创建指向页目录自己的目录项
         mov dword [es:ebx+4092],0x00020003 

         ;在页目录内创建与线性地址0x00000000对应的目录项
         mov dword [es:ebx+0],0x00021003    ;写入目录项（页表的物理地址和属性）      

这里不是`0x00020000`而是`0x00020003`的原因是：

因为在页表、页目录中，只保存页表或者页物理地址的高20位，要求`4kb`对齐，便于放在一个页中。所以低12位(2进制)都是0，也就是低3位（16进制）都是0,而实际中这些位置被用来传输一些关于这些页的信息：


在x86的分页机制中，页目录和页表的每一项都是4字节（32位）。当我们讨论物理地址时，实际上只需要高20位来表示4KB对齐的物理地址，因为这意味着这些地址的最低12位（即低3位的十六进制表示）都是0。这样，系统可以在一页（4KB）内放置1024个这样的项。

这12位不会被浪费，而是用来存储关于页的其他属性和状态信息，如存在位、读写位、用户/超级用户位等。

因此，当你看到如`0x00020003`这样的值时，高20位（在这里是`0x00020`）表示物理地址，而低12位（在这里是`3`）表示与该页相关的属性和状态信息。


1. 第0位（也即最低位）是P位，表示此页或页表是否在物理内存中（Present）。当P=1时，表示它在物理内存中；当P=0时，表示它不在物理内存中。

2. 第1位是R/W位，表示此页是否可写（Write）。当R/W=1时，此页是可写的；当R/W=0时，此页是只读的。

所以，当我们将物理地址为`0x00020000`的目录项或页表项设置为`0x00020003`时，我们实际上是在说：“这个页或页表是存在于物理内存中的（P=1），并且它是可写的（R/W=1）”。

在你给出的代码中：

- `0x00020003`可以解释为物理地址`0x00020000`，P=1，R/W=1。
- `0x00021003`可以解释为物理地址`0x00021000`，P=1，R/W=1。

因此，`0x00020003`和`0x00021003`的最后的“3”是属性位，表示这些页或页表在内存中并且是可写的。




         page_bit_map     db  0xff,0xff,0xff,0xff,0xff,0x55,0x55,0xff
                          db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
                          db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
                          db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
                          db  0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55
                          db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                          db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                          db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
页映射串低位置几乎全是ff的原因是大多被内核占据了
有些是0x55的原因，内核没有占全，中间还有空页且内核不会使用