# 传输层

## 3.2 多路复用与多路分解

- 多路复用与多路分解是所有计算机网络都需要的


## 安全性

无论是`TCP`还是`UDP`都没有提供任何加密机制。因特网界研制了`TCP`的加强版本，称为**安全套接字层(SSL)**，它不是第三种因特网运输协议，而是一种对`TCP`的加强，这种强化是在应用层实现的。

## 多路复用与多路分解

现在我们考虑接收主机怎样将一个到达的运输层报文段定向到适当的套接字。为此目的,每个运输层报文段中具有几个字段。在接收端,运输层检查这些字段,标识出接收套接字,进而将报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工作称为多路分解(demultiplexing)。

在源主机从不同套接字中收集数据块,并为每个数据块封装上首部信息(这将在以后用于分解)从而生成报文段,然后将报文段传递到网络层,所有这些工作称为多路复用(multiplexing)。

## 使用UDP的原因

1. 关于发送什么数据以及何时发送的应用层控制更为精细。有些应用可以容忍一些数据的丢失，并且时效性强。
2. 无须连接建立。
3. 无连接状态。TCP是需要在端系统维护连接状态，包含接收和发送缓存、拥塞控制参数、序列号确认号等。
4. 分组首部小。TCP头部（20+）比UDP（8）传输的信息更多，也就更大。

![UPD报文](../image/UDP报文结构.png)

## UDP校验和

[RFC 1071](https://www.rfc-editor.org/rfc/pdfrfc/rfc1071.txt.pdf)

提供校验和的原因：
- 不能保证网络传输中的所有网络核心设备都提供差错检测
- 传输过程中某台路由器的内存可能引入比特差错

虽然UDP提供差错检测，但是对差错恢复无能为力。只是丢弃受损的报文段丢弃或者交给上层应用程序并且给出警告。应用程序需要自己检测并处理数据的完整性，通常使用一种额外的校验机制，例如CRC（Cyclic Redundancy Check）来验证数据是否损坏。

## 3.4 可靠数据传输原理

！[可靠数据传输](../image/可靠数据传输:服务模型与服务实现.png)

可靠数据传输协议的下层也许是不可靠的（基本上都是不可靠的）。
`rdt`:(reliable data transfer protocol)可靠数据传输
`udt`:不可靠数据传输
### 构建可靠数据传输协议

#### 完全可靠信道的可靠数据传输:rdt 1.0

假设**底层信道完全可靠**，我们称该协议为`rdt1.0`。图中显示了`rdt1.0`发送方和接收方的[有限状态机](https://zh.wikipedia.org/zh-hans/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA)的定义。

- 发送方和接收方有各自的有限状态机。
- 该模型下发送方和接收方都只有一个状态。

发送方只通过`rdt_send(data)事件`接受来自较高层的数据，并且产生对应分组`make_pkt(data)动作`，并将分组放置在信道中。

接收方通过`rdt_rcv(data)事件`从底层信道接收一个分组，从分组中取出数据`extract(packet,data)动作`，并且传给较高层`deliver_data(data)动作`。
![rdt1.0](../image/rdt1.0.png)

由于不需要担心出现差错，接收端不需要提供反馈信息，且接收方速率和发送方一样快，不需要进行流量控制。

#### 经具有比特差错信道的可靠数据传输:rdt 2.0

- 在分组的传输、传播、缓存的过程中，这种比特差错经常处理在网络的物理部件中（交换机，路由器）。
- 假定发送的分组（可能受损）按其发送顺序被接收。

此时分组不一定传输正确，就需要接收方可以让发送方知道哪些内容被正确接收，哪些内容接收有误需要重复。基于这样的重传机制的可靠数据传输协议称为`自动重传请求(ARQ)`协议。

ARQ还需要其他三种协议功能来处理存在比特差错的情况：

- 差错检测。需要一种机制能使的接收方检测到何时出现比特差错。要求需要有额外的数据发送给接收方，接收方通过这个额外的数据来检查数据是否完好。这些额外的数据在分组的**分组校验字段**中。
- 接收方反馈。发送方需要清楚接收方的情况，就需要接收方进行对应反馈，比如肯定或者否定。类似于差错检测，我们也需要额外的数据来进行检测（只需要一个比特长，0表示否定，1表示肯定）。
- 重传。接收方收到有差错的分组时，发送方将重传该分组文。

发送方有两个状态。左边的状态是`等待来自上层的数据`：当发生`rdt_send(data)事件`时，发送方将发送一个包含待发送数据的分组（带校验和），和`rdt1.0`一样通过`make_pkt(data)动作`发送该分组；发送完进入下一个状态`等待ACK或者NAK`：发送方协议等待来自接收方的ACK或者NAK分组。如果收到ACK分组，则说明该分组已经被正确传输，因此协议返回到`等待来自上层的数据`状态，如果收到NAK分组，该协议重传上一个分组并等待接收方为响应重传分组而回送的ACK或者NAK。**重点**：当发送方处于等待ACK或者NAK的状态的时候，它不能从上层获取更多数据，除非发送方确信接收方已经正确接收到当前分组。`rdt2.0`这样的协议被称为**停等协议**。

接收方依旧只有一个状态。当分组到达时，接收方回复ACK或者NAK,如果是ACK就进行正确处理的操作。

![rdt2.0](../image/rdt2.0.png)

`rdt2.0`协议似乎可行了，但是它依旧有一个致命缺陷，如果`ACK`或者`NAK`分组受损了呢？我们可以在其分组中添加检验和比特检测这样的差错，但是更严重的问题就是：协议该如何纠正ACK/NAK分组中的差错？难点在于，如果一个ACK/NAK分组受损，发送方就不知道接收方是否正确接收到上一块发送的数据。

考虑处理受损ACK和NAK时的3种情况
  1. 假设发送方不理解接收方的`ACK`或`NAK`，发送方就会给接收方发送“你说什么？”（这是一个新的分组）。接收方复述回答。但是！如果发送的“你说什么？”产生了差错，接收方是该把这个分组当成一个新的回答还是要求重复上次回答的请求，接收方不理解，就发送一句“你说什么？”。开始套娃。
  2. 增加总够多的检验和比特，使得发送方不仅仅可以检测差错，还可以恢复差错。对于**产生差错但是不丢失分组**的情况就可以解决。
  3. 发送方受到不理解接收方的`ACK`或者`NAK`，直接重传当前数据分组。但是这在发送方到接收方的信道中引入了`冗余分组`。难点在于接收方不知道它上次的`ACK`或`NAK`是否被发送方成功接收到。因此它不清楚是新的分组还是一次重传。

为了解决这个问题，几乎所有的数据传输协议都引入了**序号**。接收方只需要检查序号就可以确定受到的分组是否是一次重传。因为目前我们假定信道不丢分组, ACK 和 NAK 分组本身不需要指明它们要确认的分组序号。发送方知道所接收到的 ACK 和 NAK 分组(无论是否是含糊不清的)是为响应其最近发送的数据分组而生成的。

新分组：序号变化了,用模 2 运算“前向“移动。
重传前一个分组：接收到的分组序号与最近收到的分组序号相同。

##### rdt 2.1/2

使用了从接收方到发送方的肯定确认和否定确认。当接收到失序的分组时，接收方对所接收的分组发送一个肯定确认。如果受到一个受损的分组，则发送一个否定确认。发送方接收到对同一个分组的两个ACK（冗余ACK）后，就知道接收方没有正确接收到跟在被确认两次的分组后面的分组。`rdt2.2`是在有比特差错的信道上实现一个无NAK的可靠数据传输协议。如果不发送NAK，而是对上次正确接收的分组发送一个ACK，也能实现与NAK一样的效果。

`rdt_rcv(rcvpkt)`指收到数据包。
发送方有四个状态（本质上还是两个状态）
![2.1 发送方](../image/rdt2.1发送方.png)
- `等待来自上层的调用0状态`：和2.0类似发送数据包并且进入`等待ACK或者NAK 0状态`。
- `等待ACK或者NAK 0状态`：
  - `corrupt(rcvpkt) || isNAK(rcvpkt)`指接收的数据包不正确或者受到NAK回复。这种情况进行重传。
  - `notcorrupt(rcvpkt) && isNAK(rcvpkt)`指收到数据包正确且有ACK回复。这种情况就进入`等待来自上层的调用1状态`。
本质处理相同，只是序列号不同，我个人认为区分为四个状态只是为了提高可读性。
![2.1 发送方](../image/rdt2.1接收方.png)
- `等待来自下层的0`：
  - `corrupt(rcvpkt)`说明数据包接收不正确。这种情况创建新的分组`make_pkt(NAK,checksum)`，并且发送给发送方。
  - `notcorrupt(rcvpkt) && has_seq1(recvpkt)`说明接收到的数据包正确且是序列号1的分组。这种情况创建新的分组`make_pkt(ACK,checksum)`，并且发给发送方。(这里与流水线传输，错误处理有关)。
  - `notcorrupt(rcvpkt) && has_seq0(recvpkt)`说明收到的数据包正确且是序列号0的分组。这种情况正常获取分组的数据并且发送ACK给发送方。

而`rdt2.2`仅仅是将NAK换成了确定接收前一个分组而不是确定当前分组，这样就能清楚是否发送成功。原理相同就不细说了。具体看图像:
![2.2 发送方](../image/rdt2.2接收方.png)
![2.2 发送方](../image/rdt2.2接收方.png)

#### 经具有比特差错的丢包信道的可靠数据传输:rdt 3.0

上面`rdt2.2`没有考虑到丢包，没有对应的逻辑处理，而3.0需要进行对应的处理。发送方如果长时间收不到响应，就认为数据包丢失。但是，该等多久才能确定数据包丢失？

显然发送方至少需要等待发送方与接收方之间的一个往返时延（中间路由器的缓冲时延 + 接收方处理一个分组需要的时间）。网络中的最大时延是很难计算的，因为影响因素很多，而确认的因素很少。理想的协议应尽可能快地从丢包中恢复；等待一个最坏情况的时延可能意味着要等待一段较长的时间，直至差错恢复为止。而这就会导致另一个问题：`冗余数据分组`。但是`rdt2.2`引入的序号已经可以解决这个情况。为了实践重传机制，需要实现一个**倒计数定时器**。在一个给定的时间量过期后，可中断发送方。发送方需要做到：

  1. 每次发送一个分组时（包含重传），启动一个定时器。
  2. 响应定时器中断（采用适当操作）。
  3. 终止定时器。

![3.0 发送方](../image/rdt3.0发送方.png)
3.0其实也就是比2.2多了个计时器，其他代码逻辑基本上相同，就不细说，看图就懂了。

### 流水线可靠协议

`rdt3.0`功能固然正确，但是性能方面十分低下，性能问题的核心在与它是一个停等协议。

假设两个端系统之间RTT是30ms。假定彼此通过一条发送速率R是1Gbps的信道。一个总长度是8000比特的分组进入1Gbps链路实际使用时间是：

\[ t_{\text{trans}} = \frac{L}{R} = \frac{8000 \text{ bits/pkt}}{10^9 \text{ bits/s}} = 8 \mu s/\text{pkt} \]

该分组经过`15ms + 0.008ms`到达接收端，接收方收到后进行差错检测等工作回复ACK，总耗时是 `15.008 + 15ms`。而这样发送方利用率十分低下：

\[ U_{\text{sender}} = \frac{L/R}{RTT + L/R} = \frac{0.008}{30.008} = 0.000 267 \]

这也就是说，发送方只有万分之2.7的时间是忙的，有效吞吐量仅仅只有`267kbps`。这太夸张了，`1Gbps`的链路仅仅只有`267kbps`的吞吐量。这还没计算双方底层协议处理时间，网络核心部件的排队和处理时延，性能只会更糟糕。

一个解决方法是：不停等，允许发送方发送多个分组而无需等待确认。因为许多从发送方向接收方输送的分组可以被看成是填充到一条流水线中，故这种技术被称为**流水线**，这会带来如下影响：
- 必须增加序号范围，因为每个输送中的分组（不包含重传）必须有唯一的序号，而且也许有多个在输送中的未确认的报文。
- 协议双方必须缓存多个分组。发送方至少需要缓存已经发送但没有确认的分组，接收方也许为了回退也要缓存已经确认的分组。
- 所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏以及延时过大的分组。基本上有两个解决方法：回退和选择重传。 

#### 回退N步 GBN(Go-Back N)

GBN协议也常被称为**滑动窗口协议**。

#### 选择重传 SR(Selective Repeat)
